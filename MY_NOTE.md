#Hi

第一讲：
1. 学习代码的审美标准
2. 任何公司都是在减少岗位，而不是增加岗位
3. 计算机——提高生产效率

4. scanf()返回值表示成功读入变量的个数
5. printf()返回值表示输出的字符数？
6. 三个printf函数：
1. printf(“%d”,n);
2. sprintf(str,”%d”,n);
3. fprintf(file,”%d”,n);
7. /dev/null 垃圾桶



8. EOF = -1    scanf 返回值为-1时 是不合法的

9. 计算机能做什么事情，一定是因为它存储了某些必要的信息。

10.          -1 的二进制表示  可以用虚拟位
			负数等于 正数的反码+1			两种记忆方式
			负数总比正数多一个！（符号位1，其余都是0的数）


11. scanf 中的方括号用法：

只要不输入换行就一直输入。
		
		这样就可以输入带空格的字符串了。

要记得用 getchar（）吞掉一个回车符


12. 维基百科 ：格式化字符串
13. 编码规范
14. C语言核心技术
第二讲：   对应C语言核心技术5-5.2  7-7.2
1. 左移 补1    ； 右移 补符号位
2. -1右移还是-1
3. abs()函数在stdlib.h 头文件里
4. acos(n)返回弧度值（π表示180°）
5. log10()  可以用来判断一个数十进制表示下的 位数！如果是其他进制的数要判断位数，可以用同样的方法，不过需要利用换底公式。
6. Arccos(-1) 的值 就是 π！ 可以用这个方法调用π！
7. pow(x,1.0/3.0)  用这种方法就可以开三次方根了。其他类推
8. 用 -lm 来包含数学库


9. #include <inttypes.h>
int16_t a;
scanf(“%” PRId16, &a);     //这样读入   不加PRId16只能读入32位的整型
printf(“%”PRId16, a);  //这样输出
printf(“%” PRIx16,a)  //把d（十进制）换成x（十六进制） 就能按十六进制输出  若换成X(大写)则是输出大写的十六进制。












10.   INT64_MAX  表示64位最大值
INT64_MIN 表示64位最小值
11. 区分左值右值 ：当代码进行到下一行，是否还能访问到上一行的值，能访问到就是左值，访问不到就是右值。





    上图中 (++c)是左值
	而（c++）返 回的是右值（临时的）  所以 （++c）++ 在C++中可以编译成功   而++c++ 不可以  因为++运算符是从右往左结合的。（百度C语言运算符优先级表）


12. while(~scanf())  为什么不用while(！scanf()) 
因为：！是条件运算 ～是位运算， 我们需要的是当scanf()返回-1的时候循环退出，而返回其他值的时候循环继续。如果用！则scanf()返回的所有值都会被运算为0，不会进入while循环。

13. 异或运算 自己是自己的逆运算     a^b=c   a^c=b   c^b=a
异或运算   表示相关位上 1 的个数的奇偶性！（）





第三讲：
1. 非零即为真
2. f(a)=!!(a)    归一化操作  将所有真值化为1
3. 表达式的值：  a=3+4 这个表达式的值是7  
若b=(a=3+4)+3  则  b为10  a为7
*逗号表达式真个表达式的值为最后一个表达式的值。
4. switch语句 case为条件入口！    如果不加break则自动执行下面的语句。
最后一个判定是 default：。。。
5. while(--n)比while(n--) 少一次循环  do while(n--) 比while(n--)多一次循环

 
6. for循环可以更好的减少变量命名。
7. while循环和for循环最主要的差别就是 初始化部分 。
8. 学习语言的三个步骤：1.背景 2.运算 3.分支结构和循环结构

9. &&  与   ||   的短路原则：
&&前面的判定已经为0了，那么就不进行后面的判定了。
因此：a=0 b=0
if((a++) &&(b++))  
输出a=1;b=0;

				a=1 b=0
				if((a++) || (b++))
			输出a=2;b=0;





10. 二进制的最后一位影响奇偶性
11. （value & 1） 等价于  （value % 2）   只有返回值为1的时候是奇数
（value & 3） 等价于  （value % 4）
（value & 7） 等价于 （value % 8）
（value & （2^i-1））  等价于  （value % 2^i） 
		value所进行与运算 的值 的二进制  在这里可以想成筛子（掩码）

第四讲：
1. 函数是压缩的数组，数组的扩展的函数！ 
2. 





3. 辗转相除







4. 扩展欧几里得  求等于1的 二元一次方程的根










第五讲
1. 异或48  ：可以将字符‘0’ 到‘9’  转化为数字 ‘0’到‘9’  
因为异或运算是自己的逆运算，所以也可以将数字0-9转化为字符0-9




第六讲

1. 将题目中的重要信息 转化为 数组的下标
2. 浮点数float的判断等于 不能判断严格等于（==）    要通过判断差值足够小来判断等于。
3. 二分查找的方法  可以看做是一个对单调函数的求解
4. 牛顿迭代法
5. 传入一个 int变量a 的地址 ，想取它的值可以用 a[0]！  a[0]可以看成只有一个元素的特殊数组。
6. 对数组名字表示的数组首地址 用 sizeof得到的是数组占得总地址大小，而对指针类型的数组首地址用sizeof得到的是指针的占地址大小。
7. 指针变量所占的字节长度与操作系统的位数有关系。32位四个字节，64位八个字节。
8. 宏定义函数 a.注意加括号     2.注意 传入a++等参数
9. __typeof()   可以在C中取得变量的类型
10. 泛型宏 ： 比如     _Generic(x)   可以根据x的类型返回对应的内容
11. __DATE__   __TIME__   宏 返回的是编译的时间
12. __LINE__    __FILE__   __func__   可以用来做输出的标记，方便查找测试记录
13. gcc -E test.c   生成编译源码
14. gcc -DDEFAULT test.c  定义DEFAULT宏   （与在代码中直接定义效果相同）   
15. memset() 是按照字节进行赋值  因此 只有memset(0) 和 memset(-1) 好使（-1的二进制每一位都是1）
16. 
